/*
 * Note1:
 * 如果写成：
 *  
 * if (velocity != 0)
 *    return distance / velocity;
 * 
 * 那么，velocity=0 时的情形将被简单的丢弃，这可能不是所期望的行为；
 * 更为健壮的处理方式是，检查是否为零，若为零则抛出除零异常，以便更高层对其进行处理；
 * 若不为零，则按正常流程进行处理；
 * 这样， 无论 velocity 是否为零， 都得到了期望的行为和处理结果。
 * 
 * Note2:
 * 异常的关键在于捕获异常。
 * 通过抛出并捕获异常，从而使程序能够应对各种不合法情形，提高程序的健壮性；
 * 如果仅仅抛出异常而不捕获，那么，程序遇到异常就会终止，
 * 在有些情况下是不被允许的。
 * 
 * 
 * Note3:
 * 如果能够避免产生异常，并且合理地进行处理，这可能是最佳的做法。
 * 毕竟，产生异常，就说明程序处理过程中蕴含了一些风险或者导致不稳定运行的因素；
 * 能够直接地去预防和消除这些因素，比起产生了再去处理要好的多。
 *
 *
 * 
 * Note: 关于继承的异常语法
 * 
 * 1. 派生类的方法的异常说明列表：
 * 
 *    ①  构造器： 是基类异常说明列表的超集；
 *    即：若基类构造器的异常说明列表为 BS = {A,B,C}，
 *    则 派生类构造器的异常说明列表 DS = BS ∪ {otherExceptions} 
 *    
 *    ②  普通覆盖方法：是 基类异常说明列表的子集；
 *    若基类的异常说明列表为BS = {A,B,C}，
 *    则派生类的异常说明列表 DS = {},{A},{B},{c},{A,B},{A,C},{B,C},{A,B,C}
 *    
 * 2. 派生类实现接口中的方法时, 其异常说明列表为基类异常说明列表的子集。 
 *  
 * 3. 异常说明不是方法类型的一部分，不能基于异常说明来重载方法；
 * 
 * 
 * Note:
 * 
 * 异常链：
 * 通过使用 exception.initCause(someException)方法，
 * 将异常对象someException 的详细信息保存在异常对象exception中供调用。
 *
 */